alex lab详解

实现lsm-tree的Memtables部分

lsm-tree在内存中维护memtables，kv写入tabel，然后落盘。主要实现table的构造，读写逻辑。

选择crossbeam-skiplist作为memtable实现，因为lock-free的skiplist相比tree更加内存友好，实现也更加容易。对于rb-tree这类数据结构缓存不友好，且lock-free性能不佳。
skiplist实现的interface会接近于rust的btreemap，包括insert get iter

区别在于，skiplist实现上述接口，只需要不可变的ref，而tree需要可变的ref，因为不需要修改节点的数据(见后续分析)。也因此可以清晰的看到，skiplist的实现不需要任何mutex来保证线程安全性。

同时，memtable不会提供delete接口，delete等价于把key对应的value置为empty

第一步是实现get和put两个接口

使用crate bytes来存储数据，这和Arc<[u8]>的区别在于，当对Bytes进行clone或者slice的时候，
底层数据不会被复制，仅构造存储的ref，内存没有引用的时候会被释放

所有修改位于mem_table.rs

```rust
pub struct MemTable {
    map: Arc<SkipMap<Bytes, Bytes>>,
    wal: Option<Wal>,
    id: usize,
    approximate_size: Arc<AtomicUsize>,
}
```

一个MemTable结构，首先包含一个map，其使用Arc来封装SkipMap,Map的key和value都是Bytes的数值段。
此处，map需要使用Arc保证多线程的引用计数访问，因为MemTable会被并发的操作。

wal，表示Write-Ahead Log，在数据的更新前记录操作，保证数据一致性和持久性。Option表示，有时候WAL是可选的。

id为标识符，不再赘述。approximate_size维护大致的大小

```rust
pub(crate) fn map_bound(bound: Bound<&[u8]>) -> Bound<Bytes> {
    match bound {
        Bound::Included(x) => Bound::Included(Bytes::copy_from_slice(x)),
        Bound::Excluded(x) => Bound::Excluded(Bytes::copy_from_slice(x)),
        Bound::Unbounded => Bound::Unbounded,
    }
}
```
pub(crate)修饰函数符号的可见性，即只在crate中可见，对外部不可见。函数接收一个Bound<&[u8]>，输出Bound<Bytes>，在rust中，bound是标准库std::ops的模块，描述一个区间的边界，是一个枚举类型

Included(T)表示闭区间的边界，Excluded表示开区间的边界，Unbounded表示无边界
例如
```rust
let bound = Bound::Included(&[1, 2, 3][..]);
let result = map_bound(bound);
```
产生了实际的数据复制

模式匹配是一种Rust中的重要写法，&[u8]表示一个字节的切片，u8是数据类型，[u8]表示数组，这是一个不可变的引用


```rust
impl MemTable {
    /// Create a new mem-table.
    pub fn create(_id: usize) -> Self {
        unimplemented!()
    }

    /// Create a new mem-table with WAL
    pub fn create_with_wal(_id: usize, _path: impl AsRef<Path>) -> Result<Self> {
        unimplemented!()
    }

    /// Create a memtable from WAL
    pub fn recover_from_wal(_id: usize, _path: impl AsRef<Path>) -> Result<Self> {
        unimplemented!()
    }
}
```
对MemTable的实现，首先是构造接口，传入参数分为








